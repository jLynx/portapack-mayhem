> alta::tcl_whisper "Cmd : [alta::prog_path] [alta::prog_version]([alta::prog_subversion])\n"
Cmd : A:/Users/jLynx/Downloads/Supra-2023.02.b0-7773ca8a-win64-all/bin/af.exe 2023.02.b0(7773ca8a)
> alta::tcl_whisper "Args : [string map {\{ \" \} \"} $tcl_cmd_args]\n"
Args : -X "set HOLDX default" -X "set MODE QUARTUS" -X "set FLOW ALL" -F ./af_run.tcl
> 
> set_seed_rand $SEED
> set ar_timing_derate ${TIMING_DERATE}
> 
> date_time
Sun Nov 03 11:19:12 2024
> if { [file exists "./${DESIGN}.pre.asf"] } {
  alta::tcl_highlight "Using pre-ASF file ${DESIGN}.pre.asf.\n"
  source "./${DESIGN}.pre.asf"
}
Using pre-ASF file portapack_h4m_cpld.pre.asf.
> 
> set LOAD_DB    false
> set LOAD_PLACE false
> set LOAD_ROUTE false
> if { $FLOW == "LOAD" || $FLOW == "CHECK" || $FLOW == "PROBE" } {
  set LOAD_DB    true
  set LOAD_PLACE true
  set LOAD_ROUTE true
} elseif { $FLOW == "R" || $FLOW == "ROUTE" } {
  set LOAD_DB    true
  set LOAD_PLACE true
}
> 
> set ORIGINAL_QSF "A:/Users/jLynx/Documents/Code/C/portapack-mayhem/hardware/portapack_h4m/CPLD/AG256SL100/./portapack_h4m_cpld.qsf"
> set ORIGINAL_PIN "A:/Users/jLynx/Documents/Code/C/portapack-mayhem/hardware/portapack_h4m/CPLD/AG256SL100/output_files/portapack_h4m_cpld.pin"
> 
> #################################################################################
> 
> while (1) {
if { [info exists CORNER] } { set_mode -corner $CORNER; }

eval "load_architect ${no_route} -type ${DEVICE} 1 1 1000 1000"
foreach ip_file $IP_FILES { read_ip $ip_file; }


if { $FLOW == "GEN" } {
  if { ! [info exists CONFIG_BITS] } {
    set CONFIG_BITS "${RESULT_DIR}/${DESIGN}.bin"
  }
  if { [llength $CONFIG_BITS] > 1 } {
    if { ! [info exists BOOT_BINARY] } {
      set BOOT_BINARY "${RESULT_DIR}/${DESIGN}_boot.bin"
    }
    if { ! [info exists CONFIG_ADDRESSES] } {
      set CONFIG_ADDRESSES ""
    }
    generate_binary -master $BOOT_BINARY -inputs $CONFIG_BITS -address $CONFIG_ADDRESSES
  } else {
    set CONFIG_ROOT   [file rootname [lindex $CONFIG_BITS 0]]
    set SLAVE_RBF     "${CONFIG_ROOT}_slave.rbf"
    set MASTER_BINARY "${CONFIG_ROOT}_master.bin"
    if { [file exists [lindex $CONFIG_BITS 0]] } {
      generate_binary -slave  $SLAVE_RBF     -inputs [lindex $CONFIG_BITS 0] -reverse
      generate_binary -master $MASTER_BINARY -inputs [lindex $CONFIG_BITS 0]
    }
    if { ! [info exists BOOT_BINARY] } {
      set BOOT_BINARY $MASTER_BINARY
    }
  }
  set PRG_FILE [file rootname $BOOT_BINARY].prg
  set AS_FILE  [file rootname $BOOT_BINARY]_as.prg
  generate_programming_file $BOOT_BINARY -erase $ERASE \
                            -program $PROGRAM -verify $VERIFY -offset $OFFSET \
                            -prg $PRG_FILE -as $AS_FILE
  break
}

if { $LOAD_DB } {
  load_db -top ${TOP_MODULE}
  set sdc "./${DESIGN}.adc"
  if { ! [file exists $sdc] } { set sdc "./${DESIGN}.sdc"; }
  if { [file exists $sdc] } { read_sdc $sdc; }

} elseif { $MODE == "QUARTUS" } {
  set verilog ${DESIGN}.vo
  set is_migrated false
  if { ! [file exists $verilog] } {
    set verilog "./simulation/modelsim/${DESIGN}.vo"
    set is_migrated true
  }
  if { ! [file exists $verilog] } {
    error "Can not find design verilog file $verilog"
  }
  alta::tcl_highlight "Using design verilog file $verilog.\n"
  set ret [read_design -top ${TOP_MODULE} -ve $VE_FILE -qsf $ORIGINAL_QSF $verilog -hierachy 1]
  if { !$ret } { exit -1; }

  set sdc "./${DESIGN}.adc"
  if { ! [file exists $sdc] } { set sdc "./${DESIGN}.sdc"; }
  if { ! [file exists $sdc] } {
    alta::tcl_warn "Can not find design SDC file $sdc"
  } else {
    alta::tcl_highlight "Using design SDC file $sdc.\n"
    read_sdc $sdc
  }

} elseif { $MODE == "SYNPLICITY" || $MODE == "NATIVE" } {
  set db_gclk_assignment_level 2
  set verilog ${DESIGN}.vqm
  set is_migrated false
  if { ! [file exists $verilog] } {
    error "Can not find design verilog file $verilog"
  }

  set sdc "./${DESIGN}.adc"
  if { ! [file exists $sdc] } { set sdc "./${DESIGN}.sdc"; }
  alta::tcl_highlight "Using design verilog file $verilog.\n"
  if { ! [file exists $sdc] } {
    alta::tcl_warn "Can not find design SDC file $sdc"
    set ret [read_design_and_pack -sdc $sdc  -top ${TOP_MODULE} $verilog]
  } else {
    alta::tcl_highlight "Using design SDC file $sdc.\n"
    set ret [read_design_and_pack -top ${TOP_MODULE} $verilog]
  }
  if { !$ret } { exit -1; }

} else {
  error "Unsupported mode $MODE"
}

if { $FLOW == "PACK" } { break }

if { [info exists FITTING] } {
  if { $FITTING == "Auto" } { set FITTING auto; }
  set_mode -fitting $FITTING
}
if { [info exists FITTER] } {
  if { $FITTER == "Auto" } {
    if { $MODE == "QUARTUS" } { set FITTER hybrid; } else { set FITTER full; }
  }
  if { $MODE == "SYNPLICITY" || $MODE == "NATIVE" } { set FITTER full; }
  set_mode -fitter $FITTER
}
if { [info exists EFFORT] } { set_mode -effort $EFFORT; }
if { [info exists SKEW  ] } { set_mode -skew   $SKEW  ; }
if { [info exists SKOPE ] } { set_mode -skope  $SKOPE ; }
if { [info exists HOLDX ] } { set_mode -holdx  $HOLDX; }
if { [info exists TUNING] } { set_mode -tuning $TUNING; }
if { [info exists TARGET] } { set_mode -target $TARGET; }
if { [info exists PRESET] } { set_mode -preset $PRESET; }
if { [info exists ADJUST] } { set pl_criticality_wadjust $ADJUST; }

set alta_aqf $::alta_work/alta.aqf
if { $LOAD_DB } {
  # Empty
} elseif { true } {
  if { [file exists $VE_FILE] } {
    set ORIGINAL_PIN ""
  } elseif { ! [file exists $ORIGINAL_PIN] } {
    if { $is_migrated } {
      error "Can not find design PIN file $ORIGINAL_PIN, please compile design first"
    }
    set ORIGINAL_PIN ""
  }
  if { [file exists $ORIGINAL_QSF] } {
    alta::convert_quartus_settings_cmd $ORIGINAL_QSF $ORIGINAL_PIN $alta_aqf
  } elseif { $is_migrated } {
    error "Can not find design exported QSF file $ORIGINAL_QSF, please export assigments first"
  }
}
if { [file exists "$alta_aqf"] } {
  alta::tcl_highlight "Using AQF file $alta_aqf.\n"
  source "$alta_aqf"
}
if { [file exists "./${DESIGN}.asf"] } {
  alta::tcl_highlight "Using ASF file ${DESIGN}.asf.\n"
  source "./${DESIGN}.asf"
}

if { $FLOW == "PROBE" } {
  set ret [place_pseudo -user_io -place_io -place_pll -place_gclk]
  if { !$ret } { exit -1 }

  set force ""
  if { [info exists PROBE_FORCE] && $PROBE_FORCE } { set force "-force" }
  eval "probe_design -froms {${PROBE_FROMS}} -tos {${PROBE_TOS}} ${force}"

} elseif { $FLOW == "CHECK" } {
  set ret [place_pseudo -user_io -place_io -place_pll -place_gclk]
  if { !$ret } { exit -1 }

  if { [file exists "./${DESIGN}.chk"] } {
    alta::tcl_highlight "Using CHK file ${DESIGN}.chk.\n"
    source "./${DESIGN}.chk"
    place_design -dry
    check_design -rule led_guide
  } else {
    error "Can not find design CHECK file ${DESIGN}.chk"
  }

} else {
  set ret [place_pseudo -user_io -place_io -place_pll -place_gclk -warn_io]
  if { !$ret } { exit -1 }

  set org_place ""
  set load_place ""
  set load_route ""
  set quiet ""
  if {  $ORG_PLACE } { set  org_place "-org_place" ; }
  if { $LOAD_PLACE } { set load_place "-load_place"; }
  if { $LOAD_ROUTE } { set load_route "-load_route"; }
  eval "place_and_route_design $org_place $load_place $load_route \
                               -retry $RETRY $seed_rand $quiet"
}

date_time
if { $FLOW != "CHECK" } {
if { $FLOW != "PROBE" } {
#report_timing -verbose 1 -file $::alta_work/timing.rpt.gz
report_timing -verbose 2 -setup -file $::alta_work/setup.rpt.gz
report_timing -verbose 2 -setup -brief -file $::alta_work/setup_summary.rpt.gz
report_timing -verbose 2 -hold -file $::alta_work/hold.rpt.gz
report_timing -verbose 2 -hold -brief -file $::alta_work/hold_summary.rpt.gz

set ta_report_auto_constraints 0
report_timing -fmax -file $::alta_work/fmax.rpt
report_timing -xfer -file $::alta_work/xfer.rpt
set ta_report_auto_constraints $ta_report_auto

#set ta_coverage_limit "0.95 0.90"
set ta_dump_uncovered 1
report_timing -verbose 1 -coverage >! $::alta_work/coverage.rpt.gz
#unset ta_coverage_limit
unset ta_dump_uncovered


if { ! [info exists rt_report_timing_fast] } {
  set rt_report_timing_fast false
}
if { $rt_report_timing_fast } {
  set_timing_corner fast
  route_delay -quiet
  report_timing -verbose 2 -setup -file $::alta_work/setup_fast.rpt.gz
  report_timing -verbose 2 -setup -brief -file $::alta_work/setup_fast_summary.rpt.gz
  report_timing -verbose 2 -hold -file $::alta_work/hold_fast.rpt.gz
  report_timing -verbose 2 -hold -brief -file $::alta_work/hold_fast_summary.rpt.gz
  set ta_report_auto_constraints 0
  report_timing -fmax -file $::alta_work/fmax_fast.rpt
  report_timing -xfer -file $::alta_work/xfer_fast.rpt
  set ta_report_auto_constraints $ta_report_auto
}

write_routed_design "${RESULT_DIR}/${RESULT}_routed.v"
}

bitgen normal -prg "${RESULT_DIR}/${RESULT}.prg" -bin "${RESULT_DIR}/${RESULT}.bin"
bitgen sram -prg "${RESULT_DIR}/${RESULT}_sram.prg"
bitgen download -bin "${RESULT_DIR}/${RESULT}.bin" -svf "${RESULT_DIR}/${RESULT}_download.svf"
generate_binary -slave "${RESULT_DIR}/${RESULT}_slave.rbf" \
                -inputs "${RESULT_DIR}/${RESULT}.bin" -reverse
generate_binary -master "${RESULT_DIR}/${RESULT}_master.bin" \
                -inputs "${RESULT_DIR}/${RESULT}.bin"
generate_programming_file "${RESULT_DIR}/${RESULT}_master.bin" -prg "${RESULT_DIR}/${RESULT}_master.prg" \
  -as "${RESULT_DIR}/${RESULT}_master_as.prg" -hybrid "${RESULT_DIR}/${RESULT}_hybrid.prg"
}
break
}
Total IO  : 104
Total Pin : 80/4
Top array is built.
Loading architect libraries...
## CPU time: 0:0:0, REAL time: 0:0:0
## Memory Usage: 30MB (30MB)
Loading route table...
## CPU time: 0:0:0, REAL time: 0:0:2
## Memory Usage: 49MB (49MB)
Using design verilog file ./simulation/modelsim/portapack_h4m_cpld.vo.
Preparing design...
## CPU time: 0:0:0, REAL time: 0:0:0
## Memory Usage: 49MB (49MB)
Pseudo pack design...
Packing Statistics
 Total      Logics : 39/256 ( 15%)
 Total        LUTs : 32/256 ( 12%)
 Total   Registers : 29/256 ( 11%)
 Total        Pins : 56/ 80 ( 70%)
 Global    Signals :  3/  4 ( 75%)
      MCU_IO_STBX~inputclkctrl_outclk (from:   MCU_IO_STBX~input_o)
      MCU_LCD_RDX~inputclkctrl_outclk (from:   MCU_LCD_RDX~input_o)
      MCU_LCD_WRX~inputclkctrl_outclk (from:   MCU_LCD_WRX~input_o)
 Total Lonely   Datain   : 0
 Total Lonely   Register : 7
 Total LUT-FF   Pairs    : 14
 Total Register Packings : 8
 Registers with synchronous    reset : 0
 Registers with asynchronous   reset : 0
 Registers with sync and async reset : 0
## CPU time: 0:0:0, REAL time: 0:0:0
## Memory Usage: 49MB (49MB)
Filter verilog...
## CPU time: 0:0:0, REAL time: 0:0:0
## Memory Usage: 49MB (49MB)
Read DB design...
## CPU time: 0:0:0, REAL time: 0:0:0
## Memory Usage: 51MB (51MB)
Process design...
> set_instance_assignment -name ENABLE_OPEN_DRAIN -to TP_U~output false
> set_instance_assignment -name ENABLE_OPEN_DRAIN -to TP_L~output false
> set_instance_assignment -name ENABLE_OPEN_DRAIN -to TP_R~output false
> set_instance_assignment -name ENABLE_OPEN_DRAIN -to TP_D~output false
> set_instance_assignment -name ENABLE_OPEN_DRAIN -to MCU_D[1]~output false
> set_instance_assignment -name ENABLE_OPEN_DRAIN -to MCU_D[2]~output false
> set_instance_assignment -name ENABLE_OPEN_DRAIN -to MCU_D[0]~output false
> set_instance_assignment -name ENABLE_OPEN_DRAIN -to MCU_D[6]~output false
> set_instance_assignment -name ENABLE_OPEN_DRAIN -to MCU_D[7]~output false
> set_instance_assignment -name ENABLE_OPEN_DRAIN -to LCD_DB[8]~output false
> set_instance_assignment -name ENABLE_OPEN_DRAIN -to LCD_DB[0]~output false
> set_instance_assignment -name ENABLE_OPEN_DRAIN -to LCD_DB[6]~output false
> set_instance_assignment -name ENABLE_OPEN_DRAIN -to LCD_DB[14]~output false
> set_instance_assignment -name ENABLE_OPEN_DRAIN -to LCD_DB[15]~output false
> set_instance_assignment -name ENABLE_OPEN_DRAIN -to LCD_DB[7]~output false
> set_instance_assignment -name ENABLE_OPEN_DRAIN -to LCD_DB[1]~output false
> set_instance_assignment -name ENABLE_OPEN_DRAIN -to MCU_D[5]~output false
> set_instance_assignment -name ENABLE_OPEN_DRAIN -to MCU_D[3]~output false
> set_instance_assignment -name ENABLE_OPEN_DRAIN -to MCU_D[4]~output false
> set_instance_assignment -name ENABLE_OPEN_DRAIN -to LCD_DB[2]~output false
> set_instance_assignment -name ENABLE_OPEN_DRAIN -to LCD_DB[9]~output false
> set_instance_assignment -name ENABLE_OPEN_DRAIN -to LCD_DB[10]~output false
> set_instance_assignment -name ENABLE_OPEN_DRAIN -to LCD_DB[13]~output false
> set_instance_assignment -name ENABLE_OPEN_DRAIN -to LCD_DB[5]~output false
> set_instance_assignment -name ENABLE_OPEN_DRAIN -to LCD_DB[3]~output false
> set_instance_assignment -name ENABLE_OPEN_DRAIN -to LCD_DB[4]~output false
> set_instance_assignment -name ENABLE_OPEN_DRAIN -to LCD_DB[11]~output false
> set_instance_assignment -name ENABLE_OPEN_DRAIN -to LCD_DB[12]~output false
> set_instance_assignment -name ENABLE_OPEN_DRAIN -to LCD_RDX~output false
> set_instance_assignment -name ENABLE_OPEN_DRAIN -to LCD_WRX~output false
> set_instance_assignment -name ENABLE_OPEN_DRAIN -to LCD_RS~output false
> set_instance_assignment -name ENABLE_OPEN_DRAIN -to MCU_LCD_TE~output false
> set_instance_assignment -name ENABLE_OPEN_DRAIN -to LCD_RESETX~output false
> set_instance_assignment -name ENABLE_OPEN_DRAIN -to REF_EN~output false
> set_instance_assignment -name ENABLE_OPEN_DRAIN -to LCD_BACKLIGHT~output false
> set_instance_assignment -name ENABLE_OPEN_DRAIN -to SYSOFF~output false
> set_instance_assignment -name ENABLE_OPEN_DRAIN -to AUDIO_RESETX~output false
> set_instance_assignment -name ENABLE_OPEN_DRAIN -to GPS_RESETX~output false
Info: Found GCLK net MCU_IO_STBX~inputclkctrl_outclk (2).
Info: Found GCLK net MCU_LCD_WRX~inputclkctrl_outclk (2).
Info: Found GCLK net MCU_LCD_RDX~inputclkctrl_outclk (4).
Info: Top level output port MCU_D[5] is identified as an inout.
Info: Top level output port MCU_D[4] is identified as an inout.
Info: Top level output port MCU_D[2] is identified as an inout.
Info: Top level output port MCU_D[1] is identified as an inout.
Info: Top level output port MCU_D[3] is identified as an inout.
Info: Top level output port MCU_D[0] is identified as an inout.
Info: Top level output port MCU_D[6] is identified as an inout.
Info: Top level output port MCU_D[7] is identified as an inout.
Info: Top level output port LCD_DB[14] is identified as an inout.
Info: Top level output port LCD_DB[9] is identified as an inout.
Info: Top level output port LCD_DB[8] is identified as an inout.
Info: Top level output port LCD_DB[4] is identified as an inout.
Info: Top level output port LCD_DB[2] is identified as an inout.
Info: Top level output port LCD_DB[6] is identified as an inout.
Info: Top level output port LCD_DB[7] is identified as an inout.
Info: Top level output port LCD_DB[0] is identified as an inout.
Info: Top level output port LCD_DB[5] is identified as an inout.
Info: Top level output port LCD_DB[3] is identified as an inout.
Info: Top level output port LCD_DB[10] is identified as an inout.
Info: Top level output port LCD_DB[11] is identified as an inout.
Info: Top level output port LCD_DB[12] is identified as an inout.
Info: Top level output port LCD_DB[13] is identified as an inout.
Info: Top level output port LCD_DB[15] is identified as an inout.
Info: Top level output port LCD_DB[1] is identified as an inout.
## CPU time: 0:0:0, REAL time: 0:0:0
## Memory Usage: 52MB (52MB)
Using design SDC file ./portapack_h4m_cpld.sdc.
read_sdc -quiet "A:/Users/jLynx/Documents/Code/C/portapack-mayhem/hardware/portapack_h4m/CPLD/AG256SL100/portapack_h4m_cpld.sdc"
> ## Generated SDC file "portapack_hackrf_one_cpld.sdc"
> 
> ## Copyright (C) 1991-2014 Altera Corporation
> ## Your use of Altera Corporation's design tools, logic functions 
> ## and other software and tools, and its AMPP partner logic 
> ## functions, and any output files from any of the foregoing 
> ## (including device programming or simulation files), and any 
> ## associated documentation or information are expressly subject 
> ## to the terms and conditions of the Altera Program License 
> ## Subscription Agreement, Altera MegaCore Function License 
> ## Agreement, or other applicable license agreement, including, 
> ## without limitation, that your use is for the sole purpose of 
> ## programming logic devices manufactured by Altera and sold by 
> ## Altera or its authorized distributors.  Please refer to the 
> ## applicable agreement for further details.
> 
> 
> ## VENDOR  "Altera"
> ## PROGRAM "Quartus II"
> ## VERSION "Version 13.1.4 Build 182 03/12/2014 SJ Web Edition"
> 
> ## DATE    "Sat May  3 10:22:18 2014"
> 
> ##
> ## DEVICE  "5M40ZE64C5"
> ##
> 
> # RS = 0, D = DB[15:8]
> #		wait max(tast = 0 ns, CPLD setup = ?)
> # WR = 0, D = DB[7:0]
> #		wait max(CPLD )
> 
> #**************************************************************
> # Time Information
> #**************************************************************
> 
> set_time_format -unit ns -decimal_places 3
> 
> set mcu_clk_period 4.9
> 
> set lcd_data_wr_setup 10.0
> set lcd_data_wr_hold 10.0
> 
> #**************************************************************
> # Create Clock
> #**************************************************************
> 
> create_clock -name {MCU_LCD_WRX} -period 66.000 -waveform { 0.000 33.000 } [get_ports {MCU_LCD_WRX}]
> #create_clock -name strobe_virt -period 66.000
> 
> #**************************************************************
> # Create Generated Clock
> #**************************************************************
> 
> 
> 
> #**************************************************************
> # Set Clock Latency
> #**************************************************************
> 
> 
> 
> #**************************************************************
> # Set Clock Uncertainty
> #**************************************************************
> 
> 
> 
> #**************************************************************
> # Set Input Delay
> #**************************************************************
> 
> #set_input_delay -clock strobe_virt [get_ports {D[*]}]
> 
> #**************************************************************
> # Set Output Delay
> #**************************************************************
> 
> 
> 
> #**************************************************************
> # Set Clock Groups
> #**************************************************************
> 
> 
> 
> #**************************************************************
> # Set False Path
> #**************************************************************
> 
> #set_false_path -from [get_clocks {MCU_IO_STBX}] -to [get_ports {TP_D TP_L TP_R TP_U}]
> #set_false_path -from [get_ports {SW_D SW_L SW_R SW_ROT_A SW_ROT_B SW_SEL SW_U}] -to [get_ports {MCU_D[*]}]
> 
> 
> #**************************************************************
> # Set Multicycle Path
> #**************************************************************
> 
> 
> 
> #**************************************************************
> # Set Maximum Delay
> #**************************************************************
> 
> 
> 
> #**************************************************************
> # Set Minimum Delay
> #**************************************************************
> 
> 
> 
> #**************************************************************
> # Set Input Transition
> #**************************************************************
> 
> # Minimal logical slice hold fix, only by routing to bram/mult, no IO delay
> 
>  set ta_cross_clock_slack "2 0"
> 
> #set pl_max_iter_hold_fix "30 1 3"
> #set pl_hold_slack_margin  0.2
> #set pl_setup_slack_margin "0.5 -1000."
> #set pl_net_hold_fix_target "alta_bram alta_bram9k alta_mult"
> 
>  set rt_hold_slack_margin  "0.2 0.2    0.2 0.2    0.2 0.7   -1000. 0.0"
>  set rt_setup_slack_margin "0.5 -1000. 0.5 -1000. 0.0 -1000."
> #set rt_net_hold_crit_minmax "0.5 0.5"
>  set rt_net_hold_budget_method 0
>  set rt_net_hold_fix_target "alta_bram alta_bram9k alta_mult"
> 
> #set pl_net_hold_fix_clock false
> #set pl_net_hold_fix_auto  false
> #set pl_net_hold_fix_io    false
> #set rt_net_hold_fix_start false
> #set rt_net_hold_fix_clock false
> #set rt_net_hold_fix_auto  false
> #set rt_net_hold_fix_io    false
Using AQF file ./alta_db/alta.aqf.
> set_global_assignment -name DEVICE_IO_STANDARD "3.3-V LVCMOS"
> set_global_assignment -name RESERVE_ALL_UNUSED_PINS "AS INPUT TRI-STATED WITH BUS-HOLD"
> set_global_assignment -name ENABLE_DEVICE_WIDE_RESET "OFF"
> set_instance_assignment -name WEAK_PULL_UP_RESISTOR "ON" -to SW_D
> set_instance_assignment -name WEAK_PULL_UP_RESISTOR "ON" -to SW_L
> set_instance_assignment -name WEAK_PULL_UP_RESISTOR "ON" -to SW_R
> set_instance_assignment -name WEAK_PULL_UP_RESISTOR "ON" -to SW_U
> set_instance_assignment -name WEAK_PULL_UP_RESISTOR "ON" -to SW_ROT_B
> set_instance_assignment -name WEAK_PULL_UP_RESISTOR "ON" -to SW_SEL
> set_instance_assignment -name WEAK_PULL_UP_RESISTOR "ON" -to SW_ROT_A
> set_instance_assignment -name SLOW_SLEW_RATE "ON" -to LCD_DB[15]
> set_instance_assignment -name SLOW_SLEW_RATE "ON" -to LCD_DB[14]
> set_instance_assignment -name SLOW_SLEW_RATE "ON" -to LCD_DB[13]
> set_instance_assignment -name SLOW_SLEW_RATE "ON" -to LCD_DB[12]
> set_instance_assignment -name SLOW_SLEW_RATE "ON" -to LCD_DB[11]
> set_instance_assignment -name SLOW_SLEW_RATE "ON" -to LCD_DB[10]
> set_instance_assignment -name SLOW_SLEW_RATE "ON" -to LCD_DB[9]
> set_instance_assignment -name SLOW_SLEW_RATE "ON" -to LCD_DB[8]
> set_instance_assignment -name SLOW_SLEW_RATE "ON" -to LCD_DB[7]
> set_instance_assignment -name SLOW_SLEW_RATE "ON" -to LCD_DB[6]
> set_instance_assignment -name SLOW_SLEW_RATE "ON" -to LCD_DB[5]
> set_instance_assignment -name SLOW_SLEW_RATE "ON" -to LCD_DB[4]
> set_instance_assignment -name SLOW_SLEW_RATE "ON" -to LCD_DB[3]
> set_instance_assignment -name SLOW_SLEW_RATE "ON" -to LCD_DB[2]
> set_instance_assignment -name SLOW_SLEW_RATE "ON" -to LCD_DB[1]
> set_instance_assignment -name SLOW_SLEW_RATE "ON" -to LCD_DB[0]
> set_instance_assignment -name SLOW_SLEW_RATE "ON" -to LCD_RDX
> set_instance_assignment -name SLOW_SLEW_RATE "ON" -to LCD_RESETX
> set_instance_assignment -name SLOW_SLEW_RATE "ON" -to LCD_RS
> set_instance_assignment -name SLOW_SLEW_RATE "ON" -to LCD_TE
> set_instance_assignment -name SLOW_SLEW_RATE "ON" -to LCD_WRX
> set_instance_assignment -name SLOW_SLEW_RATE "ON" -to MCU_ADDR
> set_instance_assignment -name SLOW_SLEW_RATE "ON" -to MCU_D[7]
> set_instance_assignment -name SLOW_SLEW_RATE "ON" -to MCU_D[6]
> set_instance_assignment -name SLOW_SLEW_RATE "ON" -to MCU_D[5]
> set_instance_assignment -name SLOW_SLEW_RATE "ON" -to MCU_D[4]
> set_instance_assignment -name SLOW_SLEW_RATE "ON" -to MCU_D[3]
> set_instance_assignment -name SLOW_SLEW_RATE "ON" -to MCU_D[2]
> set_instance_assignment -name SLOW_SLEW_RATE "ON" -to MCU_D[1]
> set_instance_assignment -name SLOW_SLEW_RATE "ON" -to MCU_D[0]
> set_instance_assignment -name SLOW_SLEW_RATE "ON" -to MCU_DIR
> set_instance_assignment -name SLOW_SLEW_RATE "ON" -to SW_D
> set_instance_assignment -name SLOW_SLEW_RATE "ON" -to SW_L
> set_instance_assignment -name SLOW_SLEW_RATE "ON" -to SW_R
> set_instance_assignment -name SLOW_SLEW_RATE "ON" -to SW_ROT_A
> set_instance_assignment -name SLOW_SLEW_RATE "ON" -to SW_ROT_B
> set_instance_assignment -name SLOW_SLEW_RATE "ON" -to SW_SEL
> set_instance_assignment -name SLOW_SLEW_RATE "ON" -to SW_U
> set_instance_assignment -name SLOW_SLEW_RATE "ON" -to TP_D
> set_instance_assignment -name SLOW_SLEW_RATE "ON" -to TP_L
> set_instance_assignment -name SLOW_SLEW_RATE "ON" -to TP_R
> set_instance_assignment -name SLOW_SLEW_RATE "ON" -to TP_U
> set_instance_assignment -name SLOW_SLEW_RATE "ON" -to LCD_BACKLIGHT
> set_instance_assignment -name SLOW_SLEW_RATE "ON" -to AUDIO_RESETX
> set_instance_assignment -name SLOW_SLEW_RATE "ON" -to MCU_LCD_RDX
> set_instance_assignment -name SLOW_SLEW_RATE "ON" -to MCU_LCD_WRX
> set_instance_assignment -name SLOW_SLEW_RATE "ON" -to MCU_IO_STBX
> set_instance_assignment -name WEAK_PULL_UP_RESISTOR "ON" -to TP_R
> set_instance_assignment -name WEAK_PULL_UP_RESISTOR "ON" -to TP_D
> set_instance_assignment -name WEAK_PULL_UP_RESISTOR "ON" -to TP_L
> set_instance_assignment -name WEAK_PULL_UP_RESISTOR "ON" -to TP_U
> set_instance_assignment -name SLOW_SLEW_RATE "ON" -to MCU_LCD_TE
> set_instance_assignment -name SLOW_SLEW_RATE "ON" -to MCU_P2_8
> set_instance_assignment -name WEAK_PULL_UP_RESISTOR "ON" -to LCD_DB[15]
> set_instance_assignment -name WEAK_PULL_UP_RESISTOR "ON" -to LCD_DB[14]
> set_instance_assignment -name WEAK_PULL_UP_RESISTOR "ON" -to LCD_DB[13]
> set_instance_assignment -name WEAK_PULL_UP_RESISTOR "ON" -to LCD_DB[12]
> set_instance_assignment -name WEAK_PULL_UP_RESISTOR "ON" -to LCD_DB[11]
> set_instance_assignment -name WEAK_PULL_UP_RESISTOR "ON" -to LCD_DB[10]
> set_instance_assignment -name WEAK_PULL_UP_RESISTOR "ON" -to LCD_DB[9]
> set_instance_assignment -name WEAK_PULL_UP_RESISTOR "ON" -to LCD_DB[8]
> set_instance_assignment -name WEAK_PULL_UP_RESISTOR "ON" -to LCD_DB[7]
> set_instance_assignment -name WEAK_PULL_UP_RESISTOR "ON" -to LCD_DB[6]
> set_instance_assignment -name WEAK_PULL_UP_RESISTOR "ON" -to LCD_DB[5]
> set_instance_assignment -name WEAK_PULL_UP_RESISTOR "ON" -to LCD_DB[4]
> set_instance_assignment -name WEAK_PULL_UP_RESISTOR "ON" -to LCD_DB[3]
> set_instance_assignment -name WEAK_PULL_UP_RESISTOR "ON" -to LCD_DB[2]
> set_instance_assignment -name WEAK_PULL_UP_RESISTOR "ON" -to LCD_DB[1]
> set_instance_assignment -name WEAK_PULL_UP_RESISTOR "ON" -to LCD_DB[0]
> set_instance_assignment -name WEAK_PULL_UP_RESISTOR "ON" -to MCU_D[7]
> set_instance_assignment -name WEAK_PULL_UP_RESISTOR "ON" -to MCU_D[6]
> set_instance_assignment -name WEAK_PULL_UP_RESISTOR "ON" -to MCU_D[5]
> set_instance_assignment -name WEAK_PULL_UP_RESISTOR "ON" -to MCU_D[4]
> set_instance_assignment -name WEAK_PULL_UP_RESISTOR "ON" -to MCU_D[3]
> set_instance_assignment -name WEAK_PULL_UP_RESISTOR "ON" -to MCU_D[2]
> set_instance_assignment -name WEAK_PULL_UP_RESISTOR "ON" -to MCU_D[1]
> set_instance_assignment -name WEAK_PULL_UP_RESISTOR "ON" -to MCU_D[0]
> set_instance_assignment -name WEAK_PULL_UP_RESISTOR "ON" -to MCU_ADDR
> set_instance_assignment -name WEAK_PULL_UP_RESISTOR "ON" -to MCU_DIR
> set_instance_assignment -name WEAK_PULL_UP_RESISTOR "ON" -to MCU_IO_STBX
> set_instance_assignment -name WEAK_PULL_UP_RESISTOR "ON" -to MCU_LCD_RDX
> set_instance_assignment -name WEAK_PULL_UP_RESISTOR "OFF" -to MCU_LCD_WRX
> set_instance_assignment -name WEAK_PULL_UP_RESISTOR "OFF" -to MCU_P2_8
> set_instance_assignment -name SLOW_SLEW_RATE "ON" -to GPS_TIMEPULSE
> set_instance_assignment -name WEAK_PULL_UP_RESISTOR "ON" -to GPS_TIMEPULSE
> set_instance_assignment -name SLOW_SLEW_RATE "ON" -to GPS_TX_READY
> set_instance_assignment -name WEAK_PULL_UP_RESISTOR "ON" -to GPS_TX_READY
> set_instance_assignment -name SLOW_SLEW_RATE "ON" -to REF_EN
> set_instance_assignment -name SLOW_SLEW_RATE "ON" -to GPS_RESETX
> set_instance_assignment -name WEAK_PULL_UP_RESISTOR "OFF" -to SYSOFF
> set_instance_assignment -name IO_STANDARD "3.3-V LVCMOS" -to AUDIO_RESETX
> set_instance_assignment -name IO_STANDARD "3.3-V LVCMOS" -to DEVICE_RESET
> set_instance_assignment -name IO_STANDARD "3.3-V LVCMOS" -to DEVICE_RESET_V
> set_instance_assignment -name IO_STANDARD "3.3-V LVCMOS" -to GPS_RESETX
> set_instance_assignment -name IO_STANDARD "3.3-V LVCMOS" -to GPS_TIMEPULSE
> set_instance_assignment -name IO_STANDARD "3.3-V LVCMOS" -to GPS_TX_READY
> set_instance_assignment -name IO_STANDARD "3.3-V LVCMOS" -to LCD_BACKLIGHT
> set_instance_assignment -name IO_STANDARD "3.3-V LVCMOS" -to LCD_DB[0]
> set_instance_assignment -name IO_STANDARD "3.3-V LVCMOS" -to LCD_DB[10]
> set_instance_assignment -name IO_STANDARD "3.3-V LVCMOS" -to LCD_DB[11]
> set_instance_assignment -name IO_STANDARD "3.3-V LVCMOS" -to LCD_DB[12]
> set_instance_assignment -name IO_STANDARD "3.3-V LVCMOS" -to LCD_DB[13]
> set_instance_assignment -name IO_STANDARD "3.3-V LVCMOS" -to LCD_DB[14]
> set_instance_assignment -name IO_STANDARD "3.3-V LVCMOS" -to LCD_DB[15]
> set_instance_assignment -name IO_STANDARD "3.3-V LVCMOS" -to LCD_DB[1]
> set_instance_assignment -name IO_STANDARD "3.3-V LVCMOS" -to LCD_DB[2]
> set_instance_assignment -name IO_STANDARD "3.3-V LVCMOS" -to LCD_DB[3]
> set_instance_assignment -name IO_STANDARD "3.3-V LVCMOS" -to LCD_DB[4]
> set_instance_assignment -name IO_STANDARD "3.3-V LVCMOS" -to LCD_DB[5]
> set_instance_assignment -name IO_STANDARD "3.3-V LVCMOS" -to LCD_DB[6]
> set_instance_assignment -name IO_STANDARD "3.3-V LVCMOS" -to LCD_DB[7]
> set_instance_assignment -name IO_STANDARD "3.3-V LVCMOS" -to LCD_DB[8]
> set_instance_assignment -name IO_STANDARD "3.3-V LVCMOS" -to LCD_DB[9]
> set_instance_assignment -name IO_STANDARD "3.3-V LVCMOS" -to LCD_RDX
> set_instance_assignment -name IO_STANDARD "3.3-V LVCMOS" -to LCD_RESETX
> set_instance_assignment -name IO_STANDARD "3.3-V LVCMOS" -to LCD_RS
> set_instance_assignment -name IO_STANDARD "3.3-V LVCMOS" -to LCD_TE
> set_instance_assignment -name IO_STANDARD "3.3-V LVCMOS" -to LCD_WRX
> set_instance_assignment -name IO_STANDARD "3.3-V LVCMOS" -to MCU_ADDR
> set_instance_assignment -name IO_STANDARD "3.3-V LVCMOS" -to MCU_DIR
> set_instance_assignment -name IO_STANDARD "3.3-V LVCMOS" -to MCU_D[0]
> set_instance_assignment -name IO_STANDARD "3.3-V LVCMOS" -to MCU_D[1]
> set_instance_assignment -name IO_STANDARD "3.3-V LVCMOS" -to MCU_D[2]
> set_instance_assignment -name IO_STANDARD "3.3-V LVCMOS" -to MCU_D[3]
> set_instance_assignment -name IO_STANDARD "3.3-V LVCMOS" -to MCU_D[4]
> set_instance_assignment -name IO_STANDARD "3.3-V LVCMOS" -to MCU_D[5]
> set_instance_assignment -name IO_STANDARD "3.3-V LVCMOS" -to MCU_D[6]
> set_instance_assignment -name IO_STANDARD "3.3-V LVCMOS" -to MCU_D[7]
> set_instance_assignment -name IO_STANDARD "3.3-V LVCMOS" -to MCU_IO_STBX
> set_instance_assignment -name IO_STANDARD "3.3-V LVCMOS" -to MCU_LCD_RDX
> set_instance_assignment -name IO_STANDARD "3.3-V LVCMOS" -to MCU_LCD_TE
> set_instance_assignment -name IO_STANDARD "3.3-V LVCMOS" -to MCU_LCD_WRX
> set_instance_assignment -name IO_STANDARD "3.3-V LVCMOS" -to MCU_P2_8
> set_instance_assignment -name IO_STANDARD "3.3-V LVCMOS" -to REF_EN
> set_instance_assignment -name IO_STANDARD "3.3V Schmitt Trigger Input" -to SW_D
> set_instance_assignment -name IO_STANDARD "3.3V Schmitt Trigger Input" -to SW_L
> set_instance_assignment -name IO_STANDARD "3.3V Schmitt Trigger Input" -to SW_R
> set_instance_assignment -name IO_STANDARD "3.3V Schmitt Trigger Input" -to SW_ROT_A
> set_instance_assignment -name IO_STANDARD "3.3V Schmitt Trigger Input" -to SW_ROT_B
> set_instance_assignment -name IO_STANDARD "3.3V Schmitt Trigger Input" -to SW_SEL
> set_instance_assignment -name IO_STANDARD "3.3V Schmitt Trigger Input" -to SW_U
> set_instance_assignment -name IO_STANDARD "3.3-V LVCMOS" -to SYSOFF
> set_instance_assignment -name IO_STANDARD "3.3-V LVCMOS" -to TP_D
> set_instance_assignment -name IO_STANDARD "3.3-V LVCMOS" -to TP_L
> set_instance_assignment -name IO_STANDARD "3.3-V LVCMOS" -to TP_R
> set_instance_assignment -name IO_STANDARD "3.3-V LVCMOS" -to TP_U
> set_instance_assignment -name CURRENT_STRENGTH_NEW "MINIMUM CURRENT" -to AUDIO_RESETX
> set_instance_assignment -name CURRENT_STRENGTH_NEW "MINIMUM CURRENT" -to GPS_RESETX
> set_instance_assignment -name CURRENT_STRENGTH_NEW "MINIMUM CURRENT" -to GPS_TIMEPULSE
> set_instance_assignment -name CURRENT_STRENGTH_NEW "MINIMUM CURRENT" -to GPS_TX_READY
> set_instance_assignment -name CURRENT_STRENGTH_NEW "MINIMUM CURRENT" -to LCD_BACKLIGHT
> set_instance_assignment -name CURRENT_STRENGTH_NEW "MINIMUM CURRENT" -to LCD_DB[0]
> set_instance_assignment -name CURRENT_STRENGTH_NEW "MINIMUM CURRENT" -to LCD_DB[10]
> set_instance_assignment -name CURRENT_STRENGTH_NEW "MINIMUM CURRENT" -to LCD_DB[11]
> set_instance_assignment -name CURRENT_STRENGTH_NEW "MINIMUM CURRENT" -to LCD_DB[12]
> set_instance_assignment -name CURRENT_STRENGTH_NEW "MINIMUM CURRENT" -to LCD_DB[13]
> set_instance_assignment -name CURRENT_STRENGTH_NEW "MINIMUM CURRENT" -to LCD_DB[14]
> set_instance_assignment -name CURRENT_STRENGTH_NEW "MINIMUM CURRENT" -to LCD_DB[15]
> set_instance_assignment -name CURRENT_STRENGTH_NEW "MINIMUM CURRENT" -to LCD_DB[1]
> set_instance_assignment -name CURRENT_STRENGTH_NEW "MINIMUM CURRENT" -to LCD_DB[2]
> set_instance_assignment -name CURRENT_STRENGTH_NEW "MINIMUM CURRENT" -to LCD_DB[3]
> set_instance_assignment -name CURRENT_STRENGTH_NEW "MINIMUM CURRENT" -to LCD_DB[4]
> set_instance_assignment -name CURRENT_STRENGTH_NEW "MINIMUM CURRENT" -to LCD_DB[5]
> set_instance_assignment -name CURRENT_STRENGTH_NEW "MINIMUM CURRENT" -to LCD_DB[6]
> set_instance_assignment -name CURRENT_STRENGTH_NEW "MINIMUM CURRENT" -to LCD_DB[7]
> set_instance_assignment -name CURRENT_STRENGTH_NEW "MINIMUM CURRENT" -to LCD_DB[8]
> set_instance_assignment -name CURRENT_STRENGTH_NEW "MINIMUM CURRENT" -to LCD_DB[9]
> set_instance_assignment -name CURRENT_STRENGTH_NEW "MINIMUM CURRENT" -to LCD_RDX
> set_instance_assignment -name CURRENT_STRENGTH_NEW "MINIMUM CURRENT" -to LCD_RESETX
> set_instance_assignment -name CURRENT_STRENGTH_NEW "MINIMUM CURRENT" -to LCD_RS
> set_instance_assignment -name CURRENT_STRENGTH_NEW "MINIMUM CURRENT" -to LCD_TE
> set_instance_assignment -name CURRENT_STRENGTH_NEW "MINIMUM CURRENT" -to LCD_WRX
> set_instance_assignment -name CURRENT_STRENGTH_NEW "MINIMUM CURRENT" -to MCU_ADDR
> set_instance_assignment -name CURRENT_STRENGTH_NEW "MINIMUM CURRENT" -to MCU_DIR
> set_instance_assignment -name CURRENT_STRENGTH_NEW "MINIMUM CURRENT" -to MCU_D[0]
> set_instance_assignment -name CURRENT_STRENGTH_NEW "MINIMUM CURRENT" -to MCU_D[1]
> set_instance_assignment -name CURRENT_STRENGTH_NEW "MINIMUM CURRENT" -to MCU_D[2]
> set_instance_assignment -name CURRENT_STRENGTH_NEW "MINIMUM CURRENT" -to MCU_D[3]
> set_instance_assignment -name CURRENT_STRENGTH_NEW "MINIMUM CURRENT" -to MCU_D[4]
> set_instance_assignment -name CURRENT_STRENGTH_NEW "MINIMUM CURRENT" -to MCU_D[5]
> set_instance_assignment -name CURRENT_STRENGTH_NEW "MINIMUM CURRENT" -to MCU_D[6]
> set_instance_assignment -name CURRENT_STRENGTH_NEW "MINIMUM CURRENT" -to MCU_D[7]
> set_instance_assignment -name CURRENT_STRENGTH_NEW "MINIMUM CURRENT" -to MCU_IO_STBX
> set_instance_assignment -name CURRENT_STRENGTH_NEW "MINIMUM CURRENT" -to MCU_LCD_RDX
> set_instance_assignment -name CURRENT_STRENGTH_NEW "MINIMUM CURRENT" -to MCU_LCD_TE
> set_instance_assignment -name CURRENT_STRENGTH_NEW "MINIMUM CURRENT" -to MCU_LCD_WRX
> set_instance_assignment -name CURRENT_STRENGTH_NEW "MINIMUM CURRENT" -to MCU_P2_8
> set_instance_assignment -name CURRENT_STRENGTH_NEW "MINIMUM CURRENT" -to REF_EN
> set_instance_assignment -name CURRENT_STRENGTH_NEW "MINIMUM CURRENT" -to SW_D
> set_instance_assignment -name CURRENT_STRENGTH_NEW "MINIMUM CURRENT" -to SW_L
> set_instance_assignment -name CURRENT_STRENGTH_NEW "MINIMUM CURRENT" -to SW_R
> set_instance_assignment -name CURRENT_STRENGTH_NEW "MINIMUM CURRENT" -to SW_ROT_A
> set_instance_assignment -name CURRENT_STRENGTH_NEW "MINIMUM CURRENT" -to SW_ROT_B
> set_instance_assignment -name CURRENT_STRENGTH_NEW "MINIMUM CURRENT" -to SW_SEL
> set_instance_assignment -name CURRENT_STRENGTH_NEW "MINIMUM CURRENT" -to SW_U
> set_instance_assignment -name CURRENT_STRENGTH_NEW "MAXIMUM CURRENT" -to SYSOFF
> set_instance_assignment -name CURRENT_STRENGTH_NEW "MAXIMUM CURRENT" -to TP_D
> set_instance_assignment -name CURRENT_STRENGTH_NEW "MAXIMUM CURRENT" -to TP_L
> set_instance_assignment -name CURRENT_STRENGTH_NEW "MAXIMUM CURRENT" -to TP_R
> set_instance_assignment -name CURRENT_STRENGTH_NEW "MAXIMUM CURRENT" -to TP_U
> set_location_assignment PIN_57 -to AUDIO_RESETX
> set_location_assignment PIN_44 -to DEVICE_RESET
> set_location_assignment PIN_38 -to DEVICE_RESET_V
> set_location_assignment PIN_73 -to GPS_RESETX
> set_location_assignment PIN_74 -to GPS_TIMEPULSE
> set_location_assignment PIN_75 -to GPS_TX_READY
> set_location_assignment PIN_76 -to LCD_BACKLIGHT
> set_location_assignment PIN_99 -to LCD_DB[0]
> set_location_assignment PIN_87 -to LCD_DB[10]
> set_location_assignment PIN_86 -to LCD_DB[11]
> set_location_assignment PIN_85 -to LCD_DB[12]
> set_location_assignment PIN_84 -to LCD_DB[13]
> set_location_assignment PIN_83 -to LCD_DB[14]
> set_location_assignment PIN_82 -to LCD_DB[15]
> set_location_assignment PIN_98 -to LCD_DB[1]
> set_location_assignment PIN_97 -to LCD_DB[2]
> set_location_assignment PIN_96 -to LCD_DB[3]
> set_location_assignment PIN_95 -to LCD_DB[4]
> set_location_assignment PIN_92 -to LCD_DB[5]
> set_location_assignment PIN_91 -to LCD_DB[6]
> set_location_assignment PIN_90 -to LCD_DB[7]
> set_location_assignment PIN_89 -to LCD_DB[8]
> set_location_assignment PIN_88 -to LCD_DB[9]
> set_location_assignment PIN_1 -to LCD_RDX
> set_location_assignment PIN_100 -to LCD_RESETX
> set_location_assignment PIN_3 -to LCD_RS
> set_location_assignment PIN_4 -to LCD_TE
> set_location_assignment PIN_2 -to LCD_WRX
> set_location_assignment PIN_42 -to MCU_ADDR
> set_location_assignment PIN_72 -to MCU_DIR
> set_location_assignment PIN_35 -to MCU_D[0]
> set_location_assignment PIN_36 -to MCU_D[1]
> set_location_assignment PIN_33 -to MCU_D[2]
> set_location_assignment PIN_30 -to MCU_D[3]
> set_location_assignment PIN_28 -to MCU_D[4]
> set_location_assignment PIN_29 -to MCU_D[5]
> set_location_assignment PIN_27 -to MCU_D[6]
> set_location_assignment PIN_26 -to MCU_D[7]
> set_location_assignment PIN_41 -to MCU_IO_STBX
> set_location_assignment PIN_39 -to MCU_LCD_RDX
> set_location_assignment PIN_40 -to MCU_LCD_TE
> set_location_assignment PIN_71 -to MCU_LCD_WRX
> set_location_assignment PIN_43 -to MCU_P2_8
> set_location_assignment PIN_58 -to REF_EN
> set_location_assignment PIN_14 -to SW_D
> set_location_assignment PIN_37 -to SW_L
> set_location_assignment PIN_12 -to SW_R
> set_location_assignment PIN_15 -to SW_ROT_A
> set_location_assignment PIN_16 -to SW_ROT_B
> set_location_assignment PIN_17 -to SW_SEL
> set_location_assignment PIN_34 -to SW_U
> set_location_assignment PIN_47 -to SYSOFF
> set_location_assignment PIN_6 -to TP_D
> set_location_assignment PIN_7 -to TP_L
> set_location_assignment PIN_5 -to TP_R
> set_location_assignment PIN_8 -to TP_U
Using ASF file portapack_h4m_cpld.asf.
Warn: Auto constraint INTERNAL: create_clock -name Internal_generated_clock_top|MCU_LCD_RDX -period 1000.000 MCU_LCD_RDX.
Warn: Auto constraint INTERNAL: create_clock -name Internal_generated_clock_top|MCU_IO_STBX -period 1000.000 MCU_IO_STBX.
Placement Statistics
 Total  Logic    Counts  : 39/256 (15.2%)
 Total  Logic    Tiles   : 8/16 (50.0%)
 Total  Valid    Nets    : 105 (77+28)
 Total  Valid    Fanouts : 352 (234+118)
 Total  Tile     Fanouts : 108
 Tile   Zip      Fanins  : 7 (3:10)
 Tile   Zip      Fanouts : 4 (1:13)
 Total  Ignored  Nets    : 27
 Total  Valid    Blocks  : 21 (8/13)
 Total  Ignored  Blocks  : 1
 Total  Zip Complexities : 60/149 1.73/103.64
 Avg    Zip   Bottleneck : 0.50 0.50
 Avg    Net   Bottleneck : 1.00 2.25
Iter #1/1 ...
Pass 1 #1/1 ...
Partitioning...
 step = 0, partition : 6,3

 step = 1, partition : 3,2
..........
 step = 2, partition : 2,2
..........
 step = 3, partition : 2,2
..........

## CPU time: 0:0:0, REAL time: 0:0:0
Pass 2 #1/1 ...
Legalization and Swapping...
..........

## CPU time: 0:0:0, REAL time: 0:0:0
Pass 3 #1/1 ...
Touchup...


## CPU time: 0:0:0, REAL time: 0:0:0
Pass 4 #1/1 ...
Optimization...
............................................................
Finishing...

## CPU time: 0:0:0, REAL time: 0:0:0
Total wire cost after placement: 0:0:0(0:0) 236.87(14.2428)+570(1)+122.333 258.683(45.1519)+115.25

*** Post Placement Timing Report ***
=== User constraints ===
=== Auto constraints ===
Coverage report
  User constraints covered 11 connections out of 196 total, coverage: 5.6%
  Auto constraints covered 40 connections out of 196 total, coverage: 20.4%
*** End Timing Report ***

route_design -dump ./alta_db/route.tx -replace ./alta_db/replace.tx 
Route Design Statistics
 Total Routing Nets : 105
 Fanout     Average : 2.35 (1..26)
 Max   Fanout  Net  : MCU_LCD_RDX~input_o
 Logic       Slices : 39/256 (15.2%)

Routing...
## CPU time: 0:0:0, REAL time: 0:0:0
 iter = 1/1, route#: 105, violation# : 11, overflow# : 11, conflict# : 19, node#: 472
## CPU time: 0:0:0, REAL time: 0:0:0
 iter = 2/2, route#: 105, violation# : 1, overflow# : 1, conflict# : 2, node#: 487
## CPU time: 0:0:0, REAL time: 0:0:0
 iter = 3/3, route#: 105, violation# : 0, overflow# : 0, conflict# : 0, node#: 488
Optimizing...
..

Done

*** Post Routing Timing Report ***
=== User constraints ===
=== Auto constraints ===
Coverage report
  User constraints covered 11 connections out of 196 total, coverage: 5.6%
  Auto constraints covered 40 connections out of 196 total, coverage: 20.4%
*** End Timing Report ***

Sun Nov 03 11:19:14 2024
Warn: User constraints coverage is too low at 5.6%.
Info: Using config file ./portapack_h4m_cpld.bin to generate download file ./portapack_h4m_cpld_download.svf.
> 
> if { [file exists "./${DESIGN}.post.asf"] } {
  alta::tcl_highlight "Using post-ASF file ${DESIGN}.post.asf.\n"
  source "./${DESIGN}.post.asf"
}
Using post-ASF file portapack_h4m_cpld.post.asf.
> date_time
Sun Nov 03 11:19:14 2024
> exit

Total 0 fatals, 0 errors, 3 warnings, 28 infos.
